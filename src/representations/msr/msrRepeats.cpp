/*
  MusicXML Library
  Copyright (C) Grame 2006-2013

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.

  Grame Research Laboratory, 11, cours de Verdun Gensoul 69002 Lyon - France
  research@grame.fr
*/

#include "msr_MUTUAL_DEPENDENCIES.h"

#include "enableTracingIfDesired.h"
#ifdef TRACING_IS_ENABLED
  #include "traceOah.h"
#endif

#include "oahOah.h"

#include "msrOah.h"


using namespace std;

namespace MusicXML2
{

//______________________________________________________________________________
/*
  Repeats in MusicXML are applied to all voices in all staves of the current part

  The currentRepeat in each voice is the top of the voice repeats stack

  A repeat is recognized in MusicXML either by:

    - it's start: handleRepeatStart
    - it's first hooked ending (45b): handleRepeatEndingStart
        the elements before is moved to the new repeat's common part
    - it's end: handleRepeatEnd

  Hooked endings following the first one are added to currentRepeat handleRepeatHookedEndingEnd

  A hookless ending terminates currentRepeat: handleRepeatHooklessEndingEnd
    finalize currentRepeat
*/

//______________________________________________________________________________
S_msrRepeatCommonPart msrRepeatCommonPart::create (
  int                 inputLineNumber,
  S_msrRepeat         repeatUpLink)
{
  msrRepeatCommonPart* o =
    new msrRepeatCommonPart (
      inputLineNumber,
      repeatUpLink);
  assert (o!=0);
  return o;
}

msrRepeatCommonPart::msrRepeatCommonPart (
  int                 inputLineNumber,
  S_msrRepeat         repeatUpLink)
    : msrElement (inputLineNumber)
{
  // sanity check
  msgAssert (
    repeatUpLink != nullptr,
    "repeatUpLink is null");

  fRepeatCommonPartRepeatUpLink = repeatUpLink;
}

msrRepeatCommonPart::~msrRepeatCommonPart ()
{}

void msrRepeatCommonPart::appendSegmentToRepeatCommonPart (
  int          inputLineNumber,
  S_msrSegment segment,
  string       context)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceSegments ()) {
    gLogStream <<
      "Appending segment '" <<
      segment->asString () <<
      "' to repeat common part '" << asString () <<
      "' (" << context << ")" <<
      ", line " << inputLineNumber <<
      endl;
  }
#endif

  // sanity check
  msgAssert (
    segment != nullptr,
    "segment is null");

  fRepeatCommonPartElementsList.push_back (segment);
}

void msrRepeatCommonPart::appendRepeatToRepeatCommonPart (
  int          inputLineNumber,
  S_msrRepeat  repeat,
  string       context)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceRepeats ()) {
    gLogStream <<
      "Appending repeat '" <<
    // JMI  repeat->asString () <<
      repeat <<
      "' to repeat common part '" << asString () <<
      "' (" << context << ")" <<
      ", line " << inputLineNumber <<
      endl;
  }
#endif

  // sanity check
  msgAssert (
    repeat != nullptr,
    "repeat is null");

  fRepeatCommonPartElementsList.push_back (repeat);
}

void msrRepeatCommonPart::appendMeasuresRepeatToRepeatCommonPart (
  int                 inputLineNumber,
  S_msrMeasuresRepeat measuresRepeat,
  string              context)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceMeasuresRepeats ()) {
    gLogStream <<
      "Appending measures repeat '" <<
      measuresRepeat->asString () <<
      "' to repeat common part '" << asString () <<
      "' (" << context << ")" <<
      ", line " << inputLineNumber <<
      endl;
  }
#endif

  // sanity check
  msgAssert (
    measuresRepeat != nullptr,
    "measuresRepeat is null");

  fRepeatCommonPartElementsList.push_back (measuresRepeat);
}

void msrRepeatCommonPart::appendRestMeasuresToRepeatCommonPart (
  int               inputLineNumber,
  S_msrRestMeasures restMeasures,
  string            context)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceRestMeasures ()) {
    gLogStream <<
      "Appending rest measures '" <<
      restMeasures->asString () <<
      "' to repeat common part '" << asString () <<
      "' (" << context << ")" <<
      ", line " << inputLineNumber <<
      endl;
  }
#endif

  // sanity check
  msgAssert (
    restMeasures != nullptr,
    "restMeasures is null");

  fRepeatCommonPartElementsList.push_back (restMeasures);
}

void msrRepeatCommonPart::appendVoiceElementToRepeatCommonPart (
  int               inputLineNumber,
  S_msrVoiceElement voiceElement,
  string            context)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceRepeats ()) {
    gLogStream <<
      "Appending voice element '" <<
      voiceElement->asString () <<
      "' to repeat common part '" << asString () <<
      "' (" << context << ")" <<
      ", line " << inputLineNumber <<
      endl;
  }
#endif

  // sanity check
  msgAssert (
    voiceElement != nullptr,
    "voiceElement is null");

  fRepeatCommonPartElementsList.push_back (voiceElement);
}

S_msrNote msrRepeatCommonPart::fetchRepeatCommonPartFirstNonGraceNote () const
{

  S_msrNote result;

  // fetch the first note in the first measure to which
  // a grace notes group can be attached
  // i.e. one not in a grace notes group itself,
  // possibly inside a chord or tuplet

  if (fRepeatCommonPartElementsList.size ()) {
    list<S_msrVoiceElement>::const_iterator
      iBegin = fRepeatCommonPartElementsList.begin (),
      iEnd   = fRepeatCommonPartElementsList.end (),
      i      = iBegin;
    for ( ; ; ) {
      S_msrVoiceElement element = (*i);

      if (
        S_msrNote note = dynamic_cast<msrNote*>(&(*element))
        ) {
        result = note;
        break;
      }

      else if (
        S_msrChord chord = dynamic_cast<msrChord*>(&(*element))
        ) {
        // get the chord's first note
        result = chord->fetchChordFirstNonGraceNote ();
        break;
      }

      else if (
        S_msrTuplet tuplet = dynamic_cast<msrTuplet*>(&(*element))
        ) {
        // get the tuplet's first note
        result = tuplet->fetchTupletFirstNonGraceNote ();
        break;
      }

      else if (
        S_msrClef clef = dynamic_cast<msrClef*>(&(*element))
        ) {
        // ignore this clef
      }

      else if (
        S_msrKey key = dynamic_cast<msrKey*>(&(*element))
        ) {
        // ignore this key
      }

      else if (
        S_msrTime time = dynamic_cast<msrTime*>(&(*element))
        ) {
        // ignore this time
      }

      else {
        stringstream s;

        s <<
          "tuplet first element should be a note, a chord or another tuplet, found instead '" <<
          element->asShortString () <<
          "'";

        msrInternalError (
          gGlobalOahOahGroup->getInputSourceName (),
          fInputLineNumber,
          __FILE__, __LINE__,
          s.str ());
      }

      if (++i == iEnd) break;
    } // for
  }

  return result;
}

void msrRepeatCommonPart::acceptIn (basevisitor* v)
{
  if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
    gLogStream <<
      "% ==> msrRepeatCommonPart::acceptIn ()" <<
      endl;
  }

  if (visitor<S_msrRepeatCommonPart>*
    p =
      dynamic_cast<visitor<S_msrRepeatCommonPart>*> (v)) {
        S_msrRepeatCommonPart elem = this;

        if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
          gLogStream <<
            "% ==> Launching msrRepeatCommonPart::visitStart ()" <<
            endl;
        }
        p->visitStart (elem);
  }
}

void msrRepeatCommonPart::acceptOut (basevisitor* v)
{
  if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
    gLogStream <<
      "% ==> msrRepeatCommonPart::acceptOut ()" <<
      endl;
  }

  if (visitor<S_msrRepeatCommonPart>*
    p =
      dynamic_cast<visitor<S_msrRepeatCommonPart>*> (v)) {
        S_msrRepeatCommonPart elem = this;

        if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
          gLogStream <<
            "% ==> Launching msrRepeatCommonPart::visitEnd ()" <<
            endl;
        }
        p->visitEnd (elem);
  }
}

void msrRepeatCommonPart::browseData (basevisitor* v)
{
  // browse the elements
  if (fRepeatCommonPartElementsList.size ()) {
    for (
      list<S_msrVoiceElement>::const_iterator i = fRepeatCommonPartElementsList.begin ();
      i != fRepeatCommonPartElementsList.end ();
      i++
  ) {
      // browse the element
      msrBrowser<msrVoiceElement> browser (v);
      browser.browse (*(*i));
    } // for
  }
}

string msrRepeatCommonPart::asString () const
{
  stringstream s;

  s <<
    "RepeatCommonPart" <<
    ", repeat upLink: '" <<
    fRepeatCommonPartRepeatUpLink->
      asShortString () <<
    "', line " << fInputLineNumber;

  return s.str ();
}

void msrRepeatCommonPart::print (ostream& os) const
{
  os <<
    "RepeatCommonPart" <<
    ", line " << fInputLineNumber <<
    endl;

  gIndenter++;

  os <<
    "repeat upLink: '" <<
    fRepeatCommonPartRepeatUpLink->
      asShortString () <<
      "'" <<
    endl << endl;

  // print the elements
  int elementsNumber =
    fRepeatCommonPartElementsList.size ();

  os <<
    "repeatCommonPartElementsList: ";
  if (elementsNumber) {
    os <<
      "(" <<
      singularOrPlural (
        elementsNumber, "element", "elements") <<
      ")";
  }
  else {
    os << "none";
  }
  os << endl;

  if (elementsNumber) {
    os << endl;

    gIndenter++;

    list<S_msrVoiceElement>::const_iterator
      iBegin = fRepeatCommonPartElementsList.begin (),
      iEnd   = fRepeatCommonPartElementsList.end (),
      i      = iBegin;

    for ( ; ; ) {
      // print the element
      os << (*i);
      if (++i == iEnd) break;
      os << endl;
    } // for

    gIndenter--;
  }

  gIndenter--;
}

void msrRepeatCommonPart::printShort (ostream& os) const
{
  os <<
    this->asShortString () <<
    endl;

/* JMI
  gIndenter++;

  os <<
    "repeat upLink: '" <<
    fRepeatCommonPartRepeatUpLink->
      asShortString () <<
      "'" <<
    endl;
*/

/* JMI
  // print the elements
  int elementsNumber =
    fRepeatCommonPartElementsList.size ();

  os <<
    "repeatCommonPartElementsList: ";
  if (elementsNumber) {
    os <<
      "(" <<
      singularOrPlural (
        elementsNumber, "element", "elements") <<
      ")";
  }
  else {
    os << "none";
  }
  os << endl;

  if (elementsNumber) {
    os << endl;

    gIndenter++;

    list<S_msrVoiceElement>::const_iterator
      iBegin = fRepeatCommonPartElementsList.begin (),
      iEnd   = fRepeatCommonPartElementsList.end (),
      i      = iBegin;

    for ( ; ; ) {
      // short print the element
      (*i)->printShort (os);
      if (++i == iEnd) break;
      os << endl;
    } // for

    gIndenter--;
  }

  gIndenter--;
*/
}

ostream& operator<< (ostream& os, const S_msrRepeatCommonPart& elt)
{
  elt->print (os);
  return os;
}

//______________________________________________________________________________
S_msrRepeatEnding msrRepeatEnding::create (
  int                 inputLineNumber,
  string              repeatEndingNumber, // may be "1, 2"
  msrRepeatEndingKind repeatEndingKind,
  S_msrRepeat         repeatUpLink)
{
  msrRepeatEnding* o =
    new msrRepeatEnding (
      inputLineNumber,
      repeatEndingNumber,
      repeatEndingKind,
      repeatUpLink);
  assert (o!=0);
  return o;
}

msrRepeatEnding::msrRepeatEnding (
  int                 inputLineNumber,
  string              repeatEndingNumber, // may be "1, 2"
  msrRepeatEndingKind repeatEndingKind,
  S_msrRepeat         repeatUpLink)
    : msrElement (inputLineNumber)
{
  fRepeatEndingNumber = repeatEndingNumber;

  fRepeatEndingInternalNumber = 0;
    // will be set by msrRepeat::addRepeatEnding ()

  fRepeatEndingKind = repeatEndingKind;

  fRepeatEndingRepeatUpLink = repeatUpLink;
}

msrRepeatEnding::~msrRepeatEnding ()
{}

void msrRepeatEnding::appendSegmentToRepeatEnding (
  int          inputLineNumber,
  S_msrSegment segment,
  string       context)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceVoices ()) {
    gLogStream <<
      "Appending segment '" << segment <<
      "' to repeat ending '" << asString () <<
      "' (" << context << ")" <<
      ", line " << inputLineNumber <<
      endl;
  }
#endif

  // sanity check
  msgAssert (
    segment != nullptr,
    "segment is null");

  fRepeatEndingElementsList.push_back (segment);
}

void msrRepeatEnding::appendRepeatToRepeatEnding (
  int          inputLineNumber,
  S_msrRepeat  repeat,
  string       context)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceVoices ()) {
    gLogStream <<
      "Appending repeat '" << repeat <<
      "' to repeat ending '" << asString () <<
      "' (" << context << ")" <<
      ", line " << inputLineNumber <<
      endl;
  }
#endif

  // sanity check
  msgAssert (
    repeat != nullptr,
    "repeat is null");

  fRepeatEndingElementsList.push_back (repeat);
}

void msrRepeatEnding::appendMeasuresRepeatToRepeatEnding (
  int                 inputLineNumber,
  S_msrMeasuresRepeat measuresRepeat,
  string              context)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceVoices ()) {
    gLogStream <<
      "Appending measures repeat '" <<
      measuresRepeat->asShortString () <<
      "' to repeat ending '" << asString () <<
      "' (" << context << ")" <<
      ", line " << inputLineNumber <<
      endl;
  }
#endif

  // sanity check
  msgAssert (
    measuresRepeat != nullptr,
    "measuresRepeat is null");

  fRepeatEndingElementsList.push_back (measuresRepeat);
}

void msrRepeatEnding::appendRestMeasuresToRepeatEnding (
  int                       inputLineNumber,
  S_msrRestMeasures restMeasures,
  string                    context)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceVoices ()) {
    gLogStream <<
      "Appending rest measures '" <<
      restMeasures->asShortString () <<
      "' to repeat ending '" << asString () <<
      "' (" << context << ")" <<
      ", line " << inputLineNumber <<
      endl;
  }
#endif

  // sanity check
  msgAssert (
    restMeasures != nullptr,
    "restMeasures is null");

  fRepeatEndingElementsList.push_back (restMeasures);
}

void msrRepeatEnding::appendVoiceElementToRepeatEnding (
  int               inputLineNumber,
  S_msrVoiceElement voiceElement,
  string            context)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceVoices ()) {
    gLogStream <<
      "Appending voice element '" << voiceElement <<
      "' to repeat ending '" << asString () <<
      "' (" << context << ")" <<
      ", line " << inputLineNumber <<
      endl;
  }
#endif

  // sanity check
  msgAssert (
    voiceElement != nullptr,
    "voiceElement is null");

  fRepeatEndingElementsList.push_back (voiceElement);
}

void msrRepeatEnding::acceptIn (basevisitor* v)
{
  if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
    gLogStream <<
      "% ==> msrRepeatEnding::acceptIn ()" <<
      endl;
  }

  if (visitor<S_msrRepeatEnding>*
    p =
      dynamic_cast<visitor<S_msrRepeatEnding>*> (v)) {
        S_msrRepeatEnding elem = this;

        if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
          gLogStream <<
            "% ==> Launching msrRepeatEnding::visitStart ()" <<
            endl;
        }
        p->visitStart (elem);
  }
}

void msrRepeatEnding::acceptOut (basevisitor* v)
{
  if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
    gLogStream <<
      "% ==> msrRepeatEnding::acceptOut ()" <<
      endl;
  }

  if (visitor<S_msrRepeatEnding>*
    p =
      dynamic_cast<visitor<S_msrRepeatEnding>*> (v)) {
        S_msrRepeatEnding elem = this;

        if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
          gLogStream <<
            "% ==> Launching msrRepeatEnding::visitEnd ()" <<
            endl;
        }
        p->visitEnd (elem);
  }
}

void msrRepeatEnding::browseData (basevisitor* v)
{
  // browse the elements
  if (fRepeatEndingElementsList.size ()) {
    for (
      list<S_msrVoiceElement>::const_iterator i = fRepeatEndingElementsList.begin ();
      i != fRepeatEndingElementsList.end ();
      i++
  ) {
      // browse the element
      msrBrowser<msrVoiceElement> browser (v);
      browser.browse (*(*i));
    } // for
  }
}

string msrRepeatEnding::repeatEndingKindAsString (
  msrRepeatEndingKind repeatEndingKind)
{
  string result;

  switch (repeatEndingKind) {
    case msrRepeatEnding::kHookedEnding:
      result = "hooked";
      break;
    case msrRepeatEnding::kHooklessEnding:
      result = "hookless";
      break;
  } // switch

  return result;
}

string msrRepeatEnding::asString () const
{
  stringstream s;

  s <<
    "RepeatEnding" <<
    ", " <<
    repeatEndingKindAsString (
      fRepeatEndingKind) <<
    ", repeatEndingRepeatUpLink: '";

  if (fRepeatEndingRepeatUpLink) {
    s <<
      fRepeatEndingRepeatUpLink->
        asShortString ();
  }
  else {
    s <<
      "none";
  }

  s <<
    ", repeatEndingNumber: " << fRepeatEndingNumber <<
    ", repeatEndingInternalNumber: " << fRepeatEndingInternalNumber <<
    "', line " << fInputLineNumber;

  return s.str ();
}

void msrRepeatEnding::print (ostream& os) const
{
  os <<
    endl <<
    "RepeatEnding" <<
    ", repeatEndingKind" << " : " <<
    repeatEndingKindAsString (
      fRepeatEndingKind) <<
    ", line " << fInputLineNumber <<
    endl;

  gIndenter++;

/* JMI
  os <<
    "repeat upLink: '" <<
    fRepeatEndingRepeatUpLink->
      asShortString () <<
      "'" <<
    endl;
*/

  const int fieldWidth = 27;

  os << left <<
    setw (fieldWidth) <<
    "repeatEndingNumber" <<  " : " <<fRepeatEndingNumber <<
    endl <<
    setw (fieldWidth) <<
    "repeatEndingInternalNumber" <<  " : " <<fRepeatEndingInternalNumber <<
    endl <<
    setw (fieldWidth) <<
    "repeat upLink" << " : '" <<
    fRepeatEndingRepeatUpLink->
      asShortString () <<
    "'" <<
    endl << endl;

  // print the elements
  int elementsNumber =
    fRepeatEndingElementsList.size ();

  os <<
    "repeatEndingElementsList: ";
  if (elementsNumber) {
    os <<
      "(" <<
      singularOrPlural (
        elementsNumber, "element", "elements") <<
      ")";
  }
  else {
    os << "none";
  }
  os << endl;

  if (elementsNumber) {
    os << endl;

    gIndenter++;

    list<S_msrVoiceElement>::const_iterator
      iBegin = fRepeatEndingElementsList.begin (),
      iEnd   = fRepeatEndingElementsList.end (),
      i      = iBegin;

    for ( ; ; ) {
      // print the element
      (*i)->print (os);
      if (++i == iEnd) break;
      os << endl;
    } // for

    gIndenter--;
  }

  gIndenter--;
}

void msrRepeatEnding::printShort (ostream& os) const
{
  os <<
    this->asShortString () <<
    endl;

/*
  gIndenter++;

  const int fieldWidth = 27;

  os << left <<
    setw (fieldWidth) <<
    "repeatEndingNumber" <<  " : " <<fRepeatEndingNumber <<
    / * JMI
    endl <<
    setw (fieldWidth) <<
    "repeatEndingInternalNumber" <<  " : " <<fRepeatEndingInternalNumber <<
    endl <<
    setw (fieldWidth) <<
    "repeat upLink: " << " : '" <<
    fRepeatEndingRepeatUpLink->
      asShortString () <<
    "'" <<
    endl <<
    * /
    endl;

/ * JMI
  os <<
    "repeat upLink: '" <<
    fRepeatEndingRepeatUpLink->
      asShortString () <<
      "'" <<
    endl;
* /

  // print the elements
  int elementsNumber =
    fRepeatEndingElementsList.size ();

  os <<
    "repeatEndingElementsList: ";
  if (elementsNumber) {
    os <<
      "(" <<
      singularOrPlural (
        elementsNumber, "element", "elements") <<
      ")";
  }
  else {
    os << "none";
  }
  os << endl;

  if (elementsNumber) {
    os << endl;

    gIndenter++;

    list<S_msrVoiceElement>::const_iterator
      iBegin = fRepeatEndingElementsList.begin (),
      iEnd   = fRepeatEndingElementsList.end (),
      i      = iBegin;

    for ( ; ; ) {
      // print the element
      (*i)->printShort (os);
      if (++i == iEnd) break;
      os << endl;
    } // for

    gIndenter--;
  }

  gIndenter--;
*/
}

ostream& operator<< (ostream& os, const S_msrRepeatEnding& elt)
{
  elt->print (os);
  return os;
}

//______________________________________________________________________________
S_msrRepeat msrRepeat::create (
  int        inputLineNumber,
  int        repeatTimes,
  S_msrVoice voiceUpLink)
{
  msrRepeat* o =
    new msrRepeat (
      inputLineNumber,
      repeatTimes,
      voiceUpLink);
  assert (o!=0);
  return o;
}

msrRepeat::msrRepeat (
  int        inputLineNumber,
  int        repeatTimes,
  S_msrVoice voiceUpLink)
    : msrVoiceElement (inputLineNumber)
{
  // sanity check
  msgAssert(
    voiceUpLink != nullptr,
    "voiceUpLink is null");

  fRepeatVoiceUpLink = voiceUpLink;

  fRepeatTimes = repeatTimes;

  fRepeatExplicitStartKind = kRepeatExplicitStartNo; // default value

  fRepeatEndingsInternalCounter = 0;

  // repeat build phase
  fCurrentRepeatBuildPhaseKind =
    msrRepeat::kRepeatBuildPhaseJustCreated;
}

S_msrRepeat msrRepeat::createRepeatNewbornClone (
  S_msrVoice containingVoice)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceRepeats ()) {
    gLogStream <<
      "Creating a newborn clone of a repeat" <<
      endl;
  }
#endif

  // sanity check
  msgAssert(
    containingVoice != nullptr,
    "containingVoice is null");

  S_msrRepeat
    newbornClone =
      msrRepeat::create (
        fInputLineNumber,
        fRepeatTimes,
        containingVoice);

  return newbornClone;
}

msrRepeat::~msrRepeat ()
{}

void msrRepeat::setRepeatCommonPart (
  S_msrRepeatCommonPart repeatCommonPart)
{
  // sanity check
  msgAssert(
    repeatCommonPart != nullptr,
    "repeatCommonPart is null");

#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceRepeats ()) {
    gLogStream <<
      "Setting repeat common part containing " <<
      singularOrPlural (
        repeatCommonPart->
          getRepeatCommonPartElementsList ().size (),
        "element",
        "elements") <<
      endl;
  }
#endif

  fRepeatCommonPart = repeatCommonPart;

  // set repeat's build phase
  fCurrentRepeatBuildPhaseKind =
    msrRepeat::kRepeatBuildPhaseInCommonPart;
}

void msrRepeat::addRepeatEndingToRepeat (
  int               inputLineNumber,
  S_msrRepeatEnding repeatEnding)
{
  // sanity check
  msgAssert(
    repeatEnding != nullptr,
    "repeatEnding is null");

#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceRepeats ()) {
    gLogStream <<
      "Adding ending '" <<
      repeatEnding->asString () <<
      "' to repeat" <<
      "' to repeat '" <<
      asShortString () <<
      "'" <<
      endl;
  }
#endif

#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceRepeatsDetails ()) {
    displayRepeat (
      inputLineNumber,
      "addRepeatEndingToRepeat() 1");
  }
#endif

  // get repeat ending kind
  msrRepeatEnding::msrRepeatEndingKind
    repeatEndingKind =
      repeatEnding->
        getRepeatEndingKind ();

  // consistency check
  switch (repeatEndingKind) {
    case msrRepeatEnding::kHookedEnding:
      switch (fCurrentRepeatBuildPhaseKind) {
        case msrRepeat::kRepeatBuildPhaseJustCreated:
          {
            stringstream s;

            s <<
              "cannot add hooked ending '" <<
              repeatEnding->asShortString () <<
              "' right after a repeat has been created";

            msrMusicXMLError (
              gGlobalOahOahGroup->getInputSourceName (),
              fInputLineNumber,
              __FILE__, __LINE__,
              s.str ());
          }
          break;
        case msrRepeat::kRepeatBuildPhaseInCommonPart:
          fCurrentRepeatBuildPhaseKind =
            msrRepeat::kRepeatBuildPhaseInEndings;
          break;
        case msrRepeat::kRepeatBuildPhaseInEndings:
          // there can be several successive endings
          break;
        case msrRepeat::kRepeatBuildPhaseCompleted:
          {
            stringstream s;

            s <<
              "cannot add hooked ending '" <<
              repeatEnding->asShortString () <<
              "' after a repeat has been completed";

            msrMusicXMLError (
              gGlobalOahOahGroup->getInputSourceName (),
              fInputLineNumber,
              __FILE__, __LINE__,
              s.str ());
          }
          break;
      } // switch
      break;

    case msrRepeatEnding::kHooklessEnding:
      switch (fCurrentRepeatBuildPhaseKind) {
        case msrRepeat::kRepeatBuildPhaseJustCreated:
          {
            stringstream s;

            s <<
              "cannot add hookless repeat ending '" <<
              repeatEnding->asShortString () <<
              "' right after the repeat has been created";

            msrInternalError (
              gGlobalOahOahGroup->getInputSourceName (),
              fInputLineNumber,
              __FILE__, __LINE__,
              s.str ());
          }
          break;
        case msrRepeat::kRepeatBuildPhaseInCommonPart:
          {
            stringstream s;

            s <<
              "cannot add hookless repeat ending '" <<
              repeatEnding->asShortString () <<
              "' right after the repeat common part";

            msrInternalError (
              gGlobalOahOahGroup->getInputSourceName (),
              fInputLineNumber,
              __FILE__, __LINE__,
              s.str ());
          }
          break;
        case msrRepeat::kRepeatBuildPhaseInEndings:
          // there can be several successive endings
          break;
        case msrRepeat::kRepeatBuildPhaseCompleted:
          {
            stringstream s;

            s <<
              "cannot add hookless ending '" <<
              repeatEnding->asShortString () <<
              "' after a repeat has been completed";

            msrMusicXMLError (
              gGlobalOahOahGroup->getInputSourceName (),
              fInputLineNumber,
              __FILE__, __LINE__,
              s.str ());
          }
      } // switch
      break;
  } // switch

  fRepeatEndings.push_back (repeatEnding);

  // set repeat ending internal number
  repeatEnding->
    setRepeatEndingInternalNumber (
      ++ fRepeatEndingsInternalCounter);

#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceRepeatsDetails ()) {
    displayRepeat (
      inputLineNumber,
      "addRepeatEndingToRepeat() 2");
  }
#endif
}

void msrRepeat::appendSegmentToRepeat (
  int          inputLineNumber,
  S_msrSegment segment,
  string       context)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceRepeats ()) {
    gLogStream <<
      "Appending segment '" <<
      segment->asString () <<
      "' to repeat '" <<
      asShortString () <<
      "'" <<
      endl;

    displayRepeat (
      inputLineNumber,
      "appendSegmentToRepeat() 1");
  }
#endif

  switch (fCurrentRepeatBuildPhaseKind) {
    case msrRepeat::kRepeatBuildPhaseJustCreated:
      {
        stringstream s;

        s <<
          "segment '" <<
          segment->asShortString () <<
          "'cannot be added to a just created repeat" <<
          " (" << context << ")";

        msrMusicXMLError (
          gGlobalOahOahGroup->getInputSourceName (),
          inputLineNumber,
          __FILE__, __LINE__,
          s.str ());
      }
      break;

    case msrRepeat::kRepeatBuildPhaseInCommonPart:
        fRepeatCommonPart->
          appendSegmentToRepeatCommonPart (
            inputLineNumber,
            segment,
            context);
      break;

    case msrRepeat::kRepeatBuildPhaseInEndings:
      fRepeatEndings.back ()->
        appendSegmentToRepeatEnding (
          inputLineNumber,
          segment,
          context);
      break;

    case msrRepeat::kRepeatBuildPhaseCompleted:
      {
        stringstream s;

        s <<
          "segment '" <<
          segment->asShortString () <<
          "'cannot be added to a completed repeat" <<
          "(" << context << ")";

        msrMusicXMLError (
          gGlobalOahOahGroup->getInputSourceName (),
          inputLineNumber,
          __FILE__, __LINE__,
          s.str ());
      }
      break;
  } // switch

#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceRepeats ()) {
    displayRepeat (
      inputLineNumber,
      "appendSegmentToRepeat() 2");
  }
#endif
}

void msrRepeat::appendRepeatToRepeat (
  int         inputLineNumber,
  S_msrRepeat repeat,
  string      context)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceRepeats ()) {
    gLogStream <<
      "Appending repeat '" <<
      repeat->asString () <<
      "' to repeat '" <<
      asShortString () <<
      "'" <<
      endl;

    displayRepeat (
      inputLineNumber,
      "appendRepeatToRepeat() 1");
  }
#endif

  switch (fCurrentRepeatBuildPhaseKind) {
    case msrRepeat::kRepeatBuildPhaseJustCreated:
      {
        stringstream s;

        s <<
          "repeat '" <<
          repeat->asShortString () <<
          "'cannot be added to a just created repeat" <<
          " (" << context << ")";

        msrMusicXMLError (
          gGlobalOahOahGroup->getInputSourceName (),
          inputLineNumber,
          __FILE__, __LINE__,
          s.str ());
      }
      break;

    case msrRepeat::kRepeatBuildPhaseInCommonPart:
        fRepeatCommonPart->
          appendRepeatToRepeatCommonPart (
            inputLineNumber,
            repeat,
            context);
      break;

    case msrRepeat::kRepeatBuildPhaseInEndings:
      fRepeatEndings.back ()->
        appendRepeatToRepeatEnding (
          inputLineNumber,
          repeat,
          context);
      break;

    case msrRepeat::kRepeatBuildPhaseCompleted:
      {
        stringstream s;

        s <<
          "repeat '" <<
          repeat->asShortString () <<
          "'cannot be added to a completed repeat" <<
          "(" << context << ")";

        msrMusicXMLError (
          gGlobalOahOahGroup->getInputSourceName (),
          inputLineNumber,
          __FILE__, __LINE__,
          s.str ());
      }
      break;
  } // switch

#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceRepeats ()) {
    displayRepeat (
      inputLineNumber,
      "appendRepeatToRepeat() 2");
  }
#endif
}

void msrRepeat::appendMeasuresRepeatToRepeat (
  int                 inputLineNumber,
  S_msrMeasuresRepeat measuresRepeat,
  string              context)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceRepeats ()) {
    gLogStream <<
      "Appending measures repeat '" <<
      measuresRepeat->asString () <<
      "' to repeat '" <<
      asShortString () <<
      "'" <<
      endl;

    displayRepeat (
      inputLineNumber,
      "appendMeasuresRepeatToRepeat() 1");
  }
#endif

  switch (fCurrentRepeatBuildPhaseKind) {
    case msrRepeat::kRepeatBuildPhaseJustCreated:
      {
        stringstream s;

        s <<
          "measures repeat '" <<
          measuresRepeat->asShortString () <<
          "'cannot be added to a just created repeat" <<
          " (" << context << ")";

        msrMusicXMLError (
          gGlobalOahOahGroup->getInputSourceName (),
          inputLineNumber,
          __FILE__, __LINE__,
          s.str ());
      }
      break;

    case msrRepeat::kRepeatBuildPhaseInCommonPart:
        fRepeatCommonPart->
          appendMeasuresRepeatToRepeatCommonPart (
            inputLineNumber,
            measuresRepeat,
            context);
      break;

    case msrRepeat::kRepeatBuildPhaseInEndings:
      fRepeatEndings.back ()->
        appendMeasuresRepeatToRepeatEnding (
          inputLineNumber,
          measuresRepeat,
          context);
      break;

    case msrRepeat::kRepeatBuildPhaseCompleted:
      {
        stringstream s;

        s <<
          "measures repeat '" <<
          measuresRepeat->asShortString () <<
          "'cannot be added to a completed repeat" <<
          "(" << context << ")";

        msrMusicXMLError (
          gGlobalOahOahGroup->getInputSourceName (),
          inputLineNumber,
          __FILE__, __LINE__,
          s.str ());
      }
      break;
  } // switch

#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceRepeats ()) {
    displayRepeat (
      inputLineNumber,
      "appendMeasuresRepeatToRepeat() 2");
  }
#endif
}

void msrRepeat::appendRestMeasuresToRepeat (
  int                       inputLineNumber,
  S_msrRestMeasures restMeasures,
  string                    context)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceRepeats ()) {
    gLogStream <<
      "Appending rest measures '" <<
      restMeasures->asString () <<
      "' to repeat '" <<
      asShortString () <<
      "'" <<
      endl;

    displayRepeat (
      inputLineNumber,
      "appendRestMeasuresToRepeat() 1");
  }
#endif

  switch (fCurrentRepeatBuildPhaseKind) {
    case msrRepeat::kRepeatBuildPhaseJustCreated:
      {
        stringstream s;

        s <<
          "rest measures '" <<
          restMeasures->asShortString () <<
          "'cannot be added to a just created repeat" <<
          " (" << context << ")";

        msrMusicXMLError (
          gGlobalOahOahGroup->getInputSourceName (),
          inputLineNumber,
          __FILE__, __LINE__,
          s.str ());
      }
      break;

    case msrRepeat::kRepeatBuildPhaseInCommonPart:
      fRepeatCommonPart->
        appendRestMeasuresToRepeatCommonPart (
          inputLineNumber,
          restMeasures,
          context);
      break;

    case msrRepeat::kRepeatBuildPhaseInEndings:
      fRepeatEndings.back ()->
        appendRestMeasuresToRepeatEnding (
          inputLineNumber,
          restMeasures,
          context);
      break;

    case msrRepeat::kRepeatBuildPhaseCompleted:
      {
        stringstream s;

        s <<
          "rest measures '" <<
          restMeasures->asShortString () <<
          "'cannot be added to a completed repeat" <<
          "(" << context << ")";

        msrMusicXMLError (
          gGlobalOahOahGroup->getInputSourceName (),
          inputLineNumber,
          __FILE__, __LINE__,
          s.str ());
      }
      break;
  } // switch

#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceRepeats ()) {
    displayRepeat (
      inputLineNumber,
      "appendRestMeasuresToRepeat() 2");
  }
#endif
}

S_msrNote msrRepeat::fetchRepeatFirstNonGraceNote () const
{
  S_msrNote result;

  if (fRepeatCommonPart) {
    result =
      fRepeatCommonPart->
        fetchRepeatCommonPartFirstNonGraceNote ();
  }

  return result;
}

void msrRepeat::acceptIn (basevisitor* v)
{
  if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
    gLogStream <<
      "% ==> msrRepeat::acceptIn ()" <<
      endl;
  }

  if (visitor<S_msrRepeat>*
    p =
      dynamic_cast<visitor<S_msrRepeat>*> (v)) {
        S_msrRepeat elem = this;

        if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
          gLogStream <<
            "% ==> Launching msrRepeat::visitStart ()" <<
            endl;
        }
        p->visitStart (elem);
  }
}

void msrRepeat::acceptOut (basevisitor* v)
{
  if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
    gLogStream <<
      "% ==> msrRepeat::acceptOut ()" <<
      endl;
  }

  if (visitor<S_msrRepeat>*
    p =
      dynamic_cast<visitor<S_msrRepeat>*> (v)) {
        S_msrRepeat elem = this;

        if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
          gLogStream <<
            "% ==> Launching msrRepeat::visitEnd ()" <<
            endl;
        }
        p->visitEnd (elem);
  }
}

void msrRepeat::browseData (basevisitor* v)
{
  if (fRepeatCommonPart) {
  // browse the common part
    msrBrowser<msrRepeatCommonPart> browser (v);
    browser.browse (*fRepeatCommonPart);
  }

  // browse the alternatives
  for (
    vector<S_msrRepeatEnding>::const_iterator i = fRepeatEndings.begin ();
    i != fRepeatEndings.end ();
    i++
  ) {
    // browse the alternative
    msrBrowser<msrRepeatEnding> browser (v);
    browser.browse (*(*i));
  } // for
}

string msrRepeat::repeatExplicitStartKindAsString (
  msrRepeatExplicitStartKind repeatExplicitStartKind)
{
  string result;

  switch (repeatExplicitStartKind) {
    case msrRepeat::kRepeatExplicitStartNo:
      result = "repeatExplicitStartNo";
      break;
    case msrRepeat::kRepeatExplicitStartYes:
      result = "repeatExplicitStartYes";
      break;
  } // switch

  return result;
}

string msrRepeat::repeatBuildPhaseKindAsString (
  msrRepeatBuildPhaseKind repeatBuildPhaseKind)
{
  string result;

  switch (repeatBuildPhaseKind) {
    case msrRepeat::kRepeatBuildPhaseJustCreated:
      result = "repeatBuildPhaseJustCreated";
      break;
    case msrRepeat::kRepeatBuildPhaseInCommonPart:
      result = "repeatBuildPhaseInCommonPart";
      break;
    case msrRepeat::kRepeatBuildPhaseInEndings:
      result = "repeatBuildPhaseInEndings";
      break;
    case msrRepeat::kRepeatBuildPhaseCompleted:
      result = "repeatBuildPhaseCompleted";
      break;
  } // switch

  return result;
}

string msrRepeat::asShortString () const
{
  stringstream s;

  s <<
    "Repeat" <<
    ", " << fRepeatTimes << " times" <<
   ", repeatExplicitStartKind: " <<
    repeatExplicitStartKindAsString (
      fRepeatExplicitStartKind) <<
    ", currentRepeatBuildPhaseKind: " <<
    repeatBuildPhaseKindAsString (
      fCurrentRepeatBuildPhaseKind);

  if (fImmediatelyPrecedingRepeat) {
    s <<
      ", fImmediatelyPrecedingRepeat: " <<
      fImmediatelyPrecedingRepeat->asShortString ();
  }
/*
  don't print the following repeat if any,
  to avoid an infinite loop
  if (fImmediatelyFollowingRepeat) {
    s <<
      ", fImmediatelyFollowingRepeat: " <<
      fImmediatelyFollowingRepeat->asShortString ();
  }
*/

  s <<
    ", common part: ";
  if (fRepeatCommonPart) {
    s <<
      singularOrPlural (
        fRepeatCommonPart->
          getRepeatCommonPartElementsList ().size (),
        "element",
        "elements");
  }
  else {
    s <<
      "none";
  }

  int repeatEndingsNumber =
    fRepeatEndings.size ();

  s <<
    ", " <<
    singularOrPlural (
      repeatEndingsNumber, "repeat ending", "repeat endings") <<
    ", line " << fInputLineNumber;

  return s.str ();
}

string msrRepeat::asString () const
{
  stringstream s;

  s <<
    "Repeat" <<
    ", " << fRepeatTimes << " times" <<
   ", repeatExplicitStartKind:: " <<
    repeatExplicitStartKindAsString (
      fRepeatExplicitStartKind) <<
    ", currentRepeatBuildPhaseKind: " <<
    repeatBuildPhaseKindAsString (
      fCurrentRepeatBuildPhaseKind);

  if (fImmediatelyPrecedingRepeat) {
    s <<
      ", fImmediatelyPrecedingRepeat: " <<
      fImmediatelyPrecedingRepeat->asShortString ();
  }
  if (fImmediatelyFollowingRepeat) {
    s <<
      ", fImmediatelyFollowingRepeat: " <<
      fImmediatelyFollowingRepeat->asShortString ();
  }

  s <<
    ", common part: ";
  if (fRepeatCommonPart) {
    s <<
      fRepeatCommonPart->asString ();
  }
  else {
    s <<
      "none";
  }

  int endingsNumber =
    fRepeatEndings.size ();

  s <<
    ", " <<
    singularOrPlural (
      endingsNumber, "repeat ending", "repeat endings");

  if (endingsNumber) {
    vector<S_msrRepeatEnding>::const_iterator
      iBegin = fRepeatEndings.begin (),
      iEnd   = fRepeatEndings.end (),
      i      = iBegin;

    s <<
      ", ";

    for ( ; ; ) {
      // print the repeat ending
      s << (*i)->asShortString ();
      if (++i == iEnd) break;
      s << " ";
    } // for
  }

  s <<
    ", line " << fInputLineNumber;

  return s.str ();
}

void msrRepeat::displayRepeat (
  int    inputLineNumber,
  string context)
{
  gLogStream <<
    endl <<
    "*********>> Repeat '" <<
    asShortString () <<
    "' (" << context << ")" <<
    ", line " << inputLineNumber <<
    " contains:" <<
    endl;

  gIndenter++;
  print (gLogStream);
  gIndenter--;

  gLogStream <<
    " <<*********" <<
    endl << endl;
}

void msrRepeat::print (ostream& os) const
{
  os <<
    "Repeat" <<
    ", " << fRepeatTimes << " times" <<
    ", line " << fInputLineNumber <<
    endl;

  gIndenter++;

  const int fieldWidth = 28;

  os << left <<
    setw (fieldWidth) <<
   "repeatExplicitStartKind" << " : " <<
    repeatExplicitStartKindAsString (
      fRepeatExplicitStartKind) <<
    endl <<
    setw (fieldWidth) <<
    "repeat ending(s)" << " : " <<
    fRepeatEndings.size () <<
    endl;

#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceRepeats ()) {
    // print the current repeat build phase
    os << left <<
      setw (fieldWidth) <<
      "currentRepeatBuildPhaseKind" << " : " <<
      repeatBuildPhaseKindAsString (
        fCurrentRepeatBuildPhaseKind) <<
      endl;
  }
#endif

  os << endl;

  // print the immediately preceding and following repeats
  os << left <<
    setw (fieldWidth) <<
    "immediatelyPrecedingRepeat" << " : ";
  if (fImmediatelyPrecedingRepeat) {
    os <<
      fImmediatelyPrecedingRepeat->asShortString ();
  }
  else {
    os << "none";
  }
  os << endl << endl;

  os << left <<
    setw (fieldWidth) <<
    "immediatelyFollowingRepeat" << " : ";
  if (fImmediatelyFollowingRepeat) {
    os <<
      fImmediatelyFollowingRepeat->asShortString ();
  }
  else {
    os << "none";
  }
  os << endl << endl;

  // print the repeat common part
  if (! fRepeatCommonPart) {
    os <<
      "Common part: none" <<
      endl;
  }
  else {
    os <<
      fRepeatCommonPart <<
      endl;
  }

  // print the repeat endings
  int endingsNumber =
    fRepeatEndings.size ();

  os <<
    "Repeat endings: ";
  if (endingsNumber) {
    os << "(" << endingsNumber << ")";
  }
  else {
    os << "none";
  }
  os << endl;

  if (endingsNumber) {
    gIndenter++;

    vector<S_msrRepeatEnding>::const_iterator
      iBegin = fRepeatEndings.begin (),
      iEnd   = fRepeatEndings.end (),
      i      = iBegin;

    for ( ; ; ) {
      // print the repeat ending
      os << (*i);
      if (++i == iEnd) break;
  // JMI    os << endl;
    } // for

    gIndenter--;
  }

  gIndenter--;
}

void msrRepeat::printShort (ostream& os) const
{
  os <<
    this->asShortString () <<
    endl;

  gIndenter++;

  // short print the repeat common part
  if (! fRepeatCommonPart) {
    os <<
      "Common part: none" <<
      endl;
  }
  else {
    fRepeatCommonPart->printShort (os);
  }

  // short print the repeat endings
  int endingsNumber =
    fRepeatEndings.size ();

  os <<
    "Repeat endings: ";
  if (endingsNumber) {
    os << "(" << endingsNumber << ")";
  }
  else {
    os << "none";
  }
  os << endl;

  if (endingsNumber) {
    gIndenter++;

    vector<S_msrRepeatEnding>::const_iterator
      iBegin = fRepeatEndings.begin (),
      iEnd   = fRepeatEndings.end (),
      i      = iBegin;

    for ( ; ; ) {
      // short print the repeat ending
      (*i)->printShort (os);
      if (++i == iEnd) break;
  // JMI    os << endl;
    } // for

    gIndenter--;
  }

  gIndenter--;
}

ostream& operator<< (ostream& os, const S_msrRepeat& elt)
{
  elt->print (os);
  return os;
}


}



//______________________________________________________________________________
/* JMI
S_msrRepeatElement msrRepeatElement::create (
  int                 inputLineNumber,
  S_msrRepeat         repeatUpLink)
{
  msrRepeatElement* o =
    new msrRepeatElement (
      inputLineNumber,
      repeatUpLink);
  assert (o!=0);
  return o;
}

msrRepeatElement::msrRepeatElement (
  int                 inputLineNumber,
  S_msrRepeat         repeatUpLink)
    : msrElement (inputLineNumber)
{
  // sanity check
  msgAssert (
    repeatUpLink != nullptr,
    "repeatUpLink is null");

  fRepeatElementRepeatUpLink = repeatUpLink;
}

msrRepeatElement::~msrRepeatElement ()
{}

void msrRepeatElement::appendSegmentToRepeatElementsList ( // JMI ???
  int          inputLineNumber,
  S_msrSegment segment,
  string       context)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceVoices ()) {
    gLogStream <<
      "Appending segment '" << segment <<
      "' to repeat element elements list '" << asString () <<
      "' (" << context << ")" <<
      ", line " << inputLineNumber <<
      endl;
  }
#endif

  // sanity check
  msgAssert (
    segment != nullptr,
    "segment is null");

  fRepeatElementElementsList.push_back (segment);
}

void msrRepeatElement::appendRepeatToRepeatElementsList (
  int          inputLineNumber,
  S_msrRepeat  repeat,
  string       context)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceVoices ()) {
    gLogStream <<
      "Appending repeat '" << repeat <<
      "' to repeat element elements list '" << asString () <<
      "' (" << context << ")" <<
      ", line " << inputLineNumber <<
      endl;
  }
#endif

  // sanity check
  msgAssert (
    repeat != nullptr,
    "repeat is null");

  fRepeatElementElementsList.push_back (repeat);
}

void msrRepeatElement::appendVoiceElementToRepeatElementsList (
  int               inputLineNumber,
  S_msrVoiceElement voiceElement,
  string            context)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTraceOahGroup->getTraceVoices ()) {
    gLogStream <<
      "Appending voice element '" << voiceElement <<
      "' to repeat element elements list '" << asString () <<
      "' (" << context << ")" <<
      ", line " << inputLineNumber <<
      endl;
  }
#endif

  // sanity check
  msgAssert (
    voiceElement != nullptr,
    "voiceElement is null");

  fRepeatElementElementsList.push_back (voiceElement);
}

S_msrNote msrRepeatElement::fetchRepeatElementFirstNonGraceNote () const
{

  S_msrNote result;

  // fetch the first note in the first measure to which
  // a grace notes group can be attached
  // i.e. one not in a grace notes group itself,
  // possibly inside a chord or tuplet

  if (fRepeatElementElementsList.size ()) {
    list<S_msrVoiceElement>::const_iterator
      iBegin = fRepeatElementElementsList.begin (),
      iEnd   = fRepeatElementElementsList.end (),
      i      = iBegin;
    for ( ; ; ) {
      S_msrVoiceElement element = (*i);

      if (
        S_msrNote note = dynamic_cast<msrNote*>(&(*element))
        ) {
        result = note;
        break;
      }

      else if (
        S_msrChord chord = dynamic_cast<msrChord*>(&(*element))
        ) {
        // get the chord's first note
        result = chord->fetchChordFirstNonGraceNote ();
        break;
      }

      else if (
        S_msrTuplet tuplet = dynamic_cast<msrTuplet*>(&(*element))
        ) {
        // get the tuplet's first note
        result = tuplet->fetchTupletFirstNonGraceNote ();
        break;
      }

      else if (
        S_msrClef clef = dynamic_cast<msrClef*>(&(*element))
        ) {
        // ignore this clef
      }

      else if (
        S_msrKey key = dynamic_cast<msrKey*>(&(*element))
        ) {
        // ignore this key
      }

      else if (
        S_msrTime time = dynamic_cast<msrTime*>(&(*element))
        ) {
        // ignore this time
      }

      else {
        stringstream s;

        s <<
          "tuplet first element should be a note, a chord or another tuplet, found instead '" <<
          element->asShortString () <<
          "'";

        msrInternalError (
          gGlobalOahOahGroup->getInputSourceName (),
          fInputLineNumber,
          __FILE__, __LINE__,
          s.str ());
      }

      if (++i == iEnd) break;
    } // for
  }

  return result;
}

void msrRepeatElement::acceptIn (basevisitor* v)
{
  if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
    gLogStream <<
      "% ==> msrRepeatElement::acceptIn ()" <<
      endl;
  }

  if (visitor<S_msrRepeatElement>*
    p =
      dynamic_cast<visitor<S_msrRepeatElement>*> (v)) {
        S_msrRepeatElement elem = this;

        if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
          gLogStream <<
            "% ==> Launching msrRepeatElement::visitStart ()" <<
            endl;
        }
        p->visitStart (elem);
  }
}

void msrRepeatElement::acceptOut (basevisitor* v)
{
  if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
    gLogStream <<
      "% ==> msrRepeatElement::acceptOut ()" <<
      endl;
  }

  if (visitor<S_msrRepeatElement>*
    p =
      dynamic_cast<visitor<S_msrRepeatElement>*> (v)) {
        S_msrRepeatElement elem = this;

        if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
          gLogStream <<
            "% ==> Launching msrRepeatElement::visitEnd ()" <<
            endl;
        }
        p->visitEnd (elem);
  }
}

void msrRepeatElement::browseData (basevisitor* v)
{
  // browse the elements
  if (fRepeatElementElementsList.size ()) {
    for (
      list<S_msrVoiceElement>::const_iterator i = fRepeatElementElementsList.begin ();
      i != fRepeatElementElementsList.end ();
      i++
  ) {
      // browse the element
      msrBrowser<msrVoiceElement> browser (v);
      browser.browse (*(*i));
    } // for
  }
}

string msrRepeatElement::asString () const
{
  stringstream s;

  s <<
    "RepeatElement" <<
    ", repeat upLink: '" <<
    fRepeatElementRepeatUpLink->
      asShortString () <<
    "', line " << fInputLineNumber <<
    endl;

  return s.str ();
}

void msrRepeatElement::print (ostream& os) const
{
  os <<
    "RepeatElement" <<
    ", line " << fInputLineNumber <<
    endl;

  gIndenter++;

  os <<
    "repeat upLink: '" <<
    fRepeatElementRepeatUpLink->
      asShortString () <<
      "'" <<
    endl << endl;

  // print the elements
  int elementsNumber =
    fRepeatElementElementsList.size ();

  os <<
    "repeatElementElementsList: ";
  if (elementsNumber) {
    os <<
      "(" <<
      singularOrPlural (
        elementsNumber, "element", "elements") <<
      ")";
  }
  else {
    os << "none";
  }
  os << endl;

  if (elementsNumber) {
    os << endl;

    gIndenter++;

    list<S_msrVoiceElement>::const_iterator
      iBegin = fRepeatElementElementsList.begin (),
      iEnd   = fRepeatElementElementsList.end (),
      i      = iBegin;

    for ( ; ; ) {
      // print the element
      os << (*i);
      if (++i == iEnd) break;
      os << endl;
    } // for

    gIndenter--;
  }

  gIndenter--;
}

void msrRepeatElement::printShort (ostream& os) const
{
  os <<
    "RepeatElement" <<
    ", line " << fInputLineNumber <<
    endl;

  gIndenter++;

/ * JMI
  os <<
    "repeat upLink: '" <<
    fRepeatElementRepeatUpLink->
      asShortString () <<
      "'" <<
    endl;
* /

  // print the elements
  int elementsNumber =
    fRepeatElementElementsList.size ();

  os <<
    "repeatElementElementsList: ";
  if (elementsNumber) {
    os <<
      "(" <<
      singularOrPlural (
        elementsNumber, "element", "elements") <<
      ")";
  }
  else {
    os << "none";
  }
  os << endl;

  if (elementsNumber) {
    os << endl;

    gIndenter++;

    list<S_msrVoiceElement>::const_iterator
      iBegin = fRepeatElementElementsList.begin (),
      iEnd   = fRepeatElementElementsList.end (),
      i      = iBegin;

    for ( ; ; ) {
      // print the element
      (*i)->printShort (os);
      if (++i == iEnd) break;
      os << endl;
    } // for

    gIndenter--;
  }

  gIndenter--;
}

ostream& operator<< (ostream& os, const S_msrRepeatElement& elt)
{
  elt->print (os);
  return os;
}
*/

